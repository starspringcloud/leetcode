## 二分查找模版一
fun()
{
   while (l<r) // 对应 r = mid
   {
     if ()
     {
       l = mid+1;
     }
     else if 
     {
       r = mid;
     }
     else 
     {
       满足条件
     }
       
   }
  return l
}

## 二分查找模版二
fun()
{
   while (l<=r) // 对应 r = mid-1
   {
     if ()
     {
       l = mid+1;
     }
     else if 
     {
       r = mid-1;
     }
     else 
     {
       满足条件
     }
       
   }
  return l
}

## dfs， 技巧在于把递归条件和题目需求条件分开写，逻辑会清楚些
{
  if (递归退出条件）
    return ;

  if (题目需求条件）
  {
    do sometion
  }

  dfs() // 递归
}

## 分治模版
fun(data, l, r)
{
  // 技巧在于这两个分开写？
  if (l == r) return data[l];
  if (l>r) return nullptr;

  mid = (l+r) >> 1;
  fun(data, l, mid);
  fun(data, mid+1,r);

}
